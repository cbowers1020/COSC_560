\documentclass[11pt, journal]{IEEEtran}
\usepackage{graphicx,latexsym}
\usepackage{longtable}
\usepackage{fullpage, setspace} %an example of how to specify two packages at once.
\usepackage[nottoc]{tocbibind}
\usepackage{textgreek}
\usepackage{enumitem}

\title{Symbolic Execution for Software Testing: Three Decades Later: A Summary}
\author{Caleb Bowers}
\date{11-5-2019}

\usepackage{titling}
\renewcommand\maketitlehooka{\null\mbox{}\vfill}
\renewcommand\maketitlehookd{\vfill\null}

\begin{document}
\begin{titlingpage}
\maketitle
\end{titlingpage}

\section{Summary}
What follows is my best attempt at summary information for \cite{Cadar2013}. This paper provides an ``overview of modern symbolic execution techniques, discus[es] their key challenges in terms of path exploration, constraint solving, and memory modeling, and discuss[es] several solutions drawn primarily from the authors' own work.'' The authors do not propose that they will provide a comprehensive summary of symbolic execution techniques, but rather they wish to highlight the key challenges as exhibited in their own work.
\subsection{Background}
Symbolic execution provides a powerful methodology for generating test suites that can offer higher coverage than traditional testing approaches, and is capable of finding errors hidden deep within complex software applications. These capabilities are provided by symbolic execution's ability to explore as many different paths of program execution as possible within a given amount of time. For each path explored, symbolic execution \textit{i}) generates a set of concrete input variables that execute along that path and \textit{ii}) checks for the presence of traditional property violations and program errors.

The historical development of symbolic execution began with the idea that researchers make use of \textit{symbolic values}, rather than actual data values as inputs to an execution instance. Additionally, program variables are represented as \textit{symbolic expressions} over the symbolic input values. The output values of a program executing on such a symbolic logic are expressed as a function of the input values. All symbolic execution paths of a program are represented in a tree structure and can all be evaluated by running the program over a set of inputs such that all the symbolic paths are explored exactly once. Symbolic execution may fail to generate an input if the constraint on a symbolic path cannot be efficiently solved by a constraint solver. More plainly, even though a symbolic input may exist and the path itself may be valid, symbolic execution will not be able to determine the veracity of this path, because of the constraint is too complex to evaluate. Similar solution restrictions exist for looping (where infinite paths may exist and only a timeout can resolve this).
\subsection{Modern Symbolic Execution Techniques}
Modern symbolic execution techniques offer the ability to mix concrete and symbolic execution, so a researcher can test their program on sample inputs for trivial input values while symbolically abstracting the more crucial for more rigorous testing. Two examples of these hybrid approaches are:
\begin{itemize}
	\item \textit{Concolic Testing}: Or, Directed Automated Random Testing
	\begin{itemize}
		\item \textit{Advantages}: 
		\begin{itemize}
			\item Maintains a concrete state and a symbolic state.
			\item Concrete state maps all variables to their concrete values.
			\item Symbolic state maps only variables that have non-concrete values.
		\end{itemize}
		\item \textit{Disadvantages}: 
		\begin{itemize}
			\item Requires initial concrete values for inputs.
			\item Could be constrained by limitations of constraint solver
		\end{itemize}
	\end{itemize}
	\item \textit{Execution-Generated Testing}
	\begin{itemize}
		\item \textit{Advantages}:
		\begin{itemize}
			\item Intermixes concrete and symbolic execution by dynamically checking if all values are concrete
			\item If all concrete, use actual program execution; otherwise, perform symbolically
		\end{itemize}
		\item \textit{Disadvantages}: 
	\end{itemize}
\end{itemize}
A big advantage to both of these methods is that by mixing the concrete and symbolic state spaces, is that the impacts of imprecision in symbolic execution and the potential timeouts of constraint solving can be reduced by the use of concrete values. This enables the intermixing method to generate test inputs for paths for which symbolic execution may get stuck. If symbolic execution is stuck, it can turn to concrete values in an attempt to resolve and avoid aborting the execution.
\subsection{Challenges and Solutions}
\subsubsection{Path Explosion}
\subsubsection{Constraint Solving}
\subsubsection{Handling Concurrency}
\subsection{Tools}
Here we have an initial section discussing tomatoes.

\bibliographystyle{IEEEtran}
\bibliography{matt_sum_bib}
\end{document}