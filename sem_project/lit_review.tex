\documentclass[12pt, fullpage]{article}
\usepackage{graphicx,latexsym}
\usepackage{longtable}
\usepackage{fullpage, setspace} %an example of how to specify two packages at once.
\usepackage[nottoc]{tocbibind}
\usepackage{textgreek}
\title{Network Multicast and Broadcast Protocol Verification: A Literature Review}
\author{Caleb Bowers}
\date{10-31-2019}

\usepackage{titling}
\renewcommand\maketitlehooka{\null\mbox{}\vfill}
\renewcommand\maketitlehookd{\vfill\null}

\begin{document}
\begin{titlingpage}
\maketitle
\end{titlingpage}

\tableofcontents

\section{Introduction}
% Focusing more on the formal verification of *Multicast* and *Broadcast* Network protocols, not just broadly network protocols
The past thirty years has seen significant improvement in how formal method and verification researchers approach verifying computer networking protocols. Traditionally, during development and implementation, the protocol would undergo extensive testing as the primary method of verifying that the performance of the protocol matched the design specification and the expected functionality. If the protocol behavior mirrored that of the design specification, then researchers and designers felt confident enough to label the protocol ``verified''. This approach does not concretely verify the protocol, but does prevent obvious errors from existing and can come close to ensuring functionality in expected operational conditions. Extensive testing, however, only verifies the behavior of the specification for that specific tested domain, and does not logically verify the specification itself.
\bigbreak
Extensive testing methods work fairly well for day to day unicast Internet protocols where the operating conditions are more predictable and the implementation less complex. There exists a gap, however, for multicast and broadcast networking protocols (hereafter, multicast\footnote{It should be noted that multicast is a subset of broadcast. Broadcast entails a sender transmitting to all network participants, whereas multicast describes a sender transmitting to a \textit{subgroup} of participants}) and researchers have sought to develop more rigorous formal methods for these networking protocols. In multicast environments the participants are often widely distributed and senders only know the group address, rather than the address of each participant (as is the case in unicast). The multicast communications paradigm requires more complex mechanisms of reliability and transmission to ensure efficient performance of the protocol. Implementing these mechanisms leads to an explosion of state space, which further limits the efficacy of extensive testing since that is often domain specific and is limited in time by the number of actual testable domains. Additionally, as previously mentioned, a specification may produce proper behavior amidst most operational conditions, but not be logically sound, so a possibility for error exists somewhere in the behavioral domain for that specification. Formally verifying these complex multicast mechanisms, therefore, remains necessary and is increasingly important as more communication becomes distributed and asynchronous.
\bigbreak
The goal of this paper is to review several of the primary literature sources and seminal results that have contributed to the field of formal multicast network protocol specification. The literature sampled ranges from fundamental theory and the development of formal methods for multicast protocol verification, to highlighting the development and workings of the tools used in practice to verify multicast protocols.

\section{Background}
\bigbreak
\subsection{Network Protocols}
In computer networking communication and protocol verification, we break communication into three main paradigms
\begin{itemize}
	\item \textit{unicast}: A sender transmits to a single receiver. Internet protocols operate on this model.
	\item \textit{broadcast}: A sender transmits to all nodes on the network. This is how computers find printers on a local subnet.
	\item \textit{multicast}: A sender transmits to a subgroup of nodes on the network.
\end{itemize}
\bigbreak
Multicast communication enables a sender to transmit a message to a specific group address, or a multicast address \cite{Lien2004FormalMA}. Once the message is transmitted to this address, delivery of the message to every member of the group depends on the multicast network protocol. When specifying requirements for a multicast protocol, reliability is often provided by balancing the tradeoffs of feedback/retransmission strategies with the ability to scale to a large number of nodes across a wide network. If the protocol creates too much traffic, it will not scale well on its own as a communications protocol, nor will it be useful in larger networking contexts where the multicast protocol must share resources with other communication protocols. The focus of this literature review is to provide an understanding of the literature that has contributed most notably to the development of formal methods for communication protocols and specifically, multicast communication protocols.

\section{Literature Overview}
\bigbreak
\subsection{Early Protocol Verification}
In \cite{Bochman1980} we see an early investigation into the use of formal methods in the designing of communication protocols. The 1980's saw a proliferation of complex protocols across an increasingly large and distributed networks. These protocols were often designed using extensive testing and narrative description (i.e., implementation use-cases), but design was rarely approached from a logical framework. As the use of these protocols increased, the variety of different implementations for a given protocol also increased. This further escalated the complexity of the protocol to ensure design compliance, which created the need for more formalized design and implementation verification methods. 
\bigbreak
In \cite{Bochman1980}, the authors begin their work by defining what constitutes a protocol specification. A protocol specification, broadly speaking, consists of two parts: service specification and protocol specification. A service specification is generally based on a set of service primitives and some examples include: \textit{Connect, Disconnect, Send,} and \textit{Receive}. A protocol specification ``must describe the operation of each entity within a layer in response to commands from its users, messages from the other entities \ldots\ and internally initiated actions (e.g., timeouts)'' (here an entity is a process or module local to each protocol implementation) \cite{Bochman1980}. The description of the operations of each entity within the protocol layer define the actual protocol when interacting across entities; therefore, early formal methods being developed for protocol verification focused primarily on the protocol \textit{design} specifications, since this is concerned with the actual communication (and implementation verification can be viewed as the more common program verification problem). Protocol design verification methods leveraged general formalisms such as Petri nets, state analysis, and verification programming languages \cite{Petri1966}. 
\bigbreak
Finally, when actually attempting to verify a protocol, early verification in practice could be classified in either reachability analysis or program proofs. Reachability analysis exhaustively analyzes all of the possible interactions two or more entities may experience when using a given communication protocol. To verify, we define a global state composed of the states of the protocol and connected entities. From a start state, all possible transition states are generated and the possible combinations of these form new global states, which need to be tested for conformance to the protocol design specifications. Program proofs for protocols pose some difficulty since protocols can be unreliable (nondeterministic) and are often concurrent when multiple entities are involved, which prevents entities from sharing the same set of variables and causing the proof variable space to explode. Often proofs on protocols occur on topologies: a property is shown to be true for some subset and then inducted for \textit{n, n+1} entities. 
\bigbreak
To avoid an explosion in the state space, several methods are available specific to protocol design verification. Verifiers may focus on verifying only a portion of the specification, that which is often most critical to correct protocol function. Additionally, verifiers may reduce those state transitions that are indivisible into a single transition (e.g., wrapping a packet and then sending it could be viewed as one state). A protocol may also be decomposed into its sublayers/phases of operation to simplify the description and verification of properties relevant to those sublayers. By verifying each layer, the protocol can then be verified. Assertions that are predicates can be defined for a set of states and verifying these assertions enables the verification for all possible states as long as assertions exist to cover all possible states. State space can further be reduced by combing assertions with a focused search approach that reduces the state space from a global view to those that can be predetermined as potential states for some assertion (e.g., deadlock). 
\bigbreak
The paper concludes by providing examples of early adopters of protocol verification design strategies, namely, the ARPANET Initial Connection protocol and the Cyclades transport protocol. The authors then set the expectation that more fundamental formal methods will be developed that can be extended to more complex and actually implemented protocols. Building off this expectation the next section will examine how the literature has progressed to address the inherently more complex operation of multicast protocols, which exhibit the more challenging behaviors to verify (e.g., concurrent transmissions/connections, unreliability, etc.).
\bigbreak
\subsection{Early Multicast Protocol Verification}
The motivation for \cite{Creese1999} came from the state of protocol verification at that time. As briefly alluded to in the previous section, formal specification and verification of communication protocols focused primarily on link level properties between fixed entities (e.g, sender and receiver) leveraging a fixed number of lower layer services and components. This approach does not enable the verification of protocols as they are used in the real world where communications happen between an exponential number of entities across complex protocols that make use of an arbitrary number of lower layer services. 
\bigbreak
To account for the arbitrary nature of protocol operational requirements, the authors shift from a strict model checking approach, to a technique that uses induction to prove correctness of protocol specifications and properties. They implement this method using a software package developed by Formal Systems Ltd. called FDR that is based on the theory of Communicating Sequential Processes (CSP). To provide inductive capability for an arbitrary number of components, the authors extended the original CSP theory by using lazy abstraction\footnote{Lazy abstraction compresses the abstract-check-refine process into a single process to ``continuously builds and refines a single abstract model on demand, driven by the model checker, so that different parts of the model may exhibit different degrees of precision, namely just enough to verify the desired property.'' \cite{Henzinger2002}} and model checking components that do not exhibit inductive behavior in order to verify all properties of the given protocol. 
\bigbreak
Layered protocols lend themselves to examination as finite state machines (FSM), since each layer can be expressed as an FSM and the correctness of each layer's FSM impacts the following layer's correctness. While FSMs account for the layered nature of protocols, they fail to address the unbounded network topology that can be encountered by an operational protocol. These topologies at this time were modeled as an action system operating a process which interacts with its environment through discrete events. This enables a system to reduce a process to a sequence of events and this sequence itself can be verified. The authors used this as motivation to select CSP/FDR as their formal verification method. CSP/FDR are formalisms that combine programming languages (CSP) and finite state machines (FDR).
\bigbreak
The authors test their induction method on the RSVP multicast reservation protocol that operates on IP networks \cite{rfc2205}. RSVP multicasts from information sources to receivers by ``transmitting along a number of intermediate links shared by ``downstream'' nodes.'' RSVP then creates and maintains the reservations along each link of the previously defined multicast route. The route is finite from a ``downstream'' node to the original source node and can contain any number of links or nodes in between.
\bigbreak
By employing Lazy Abstraction the authors reduce an unbounded state space to a finite space by abstracting away the unbounded components of the multicast network. They achieve this by viewing the protocol from the perspective of a downstream node in the behavior specification of the protocol as it moves along the upstream link towards the sender.
\bigbreak
The creation of the model in this paper examines the traffic reducing nature of RSVP (intermediate nodes can automatically respond to requests that they have already seen. They use FDR to perform a \textit{structural induction} that establishes the properties for the end-to-end nature of RSVP by a series of refinement checks that actually comprise the inductive proof. Having established the validity of the inductive proof fo any arbitrary multicast route between nodes, the authors proceed to evaluate this method on a multicast network in the form of a tree with the source as the root node and the receivers forming the leaf nodes of the tree. They construct a general model of a network node, apply the inductive properties, and establish the communication primitives for root, leaf, and intermediate nodes and somewhat cleverly reduce an intermediate node to that of a source for downstream communications, which simplifies the necessary verification steps. It is important to note that the downstream communication properties for arbitrary routes and nodes are verified through induction, which is the main contribution of this paper. This means that for each communication property the authors establish a base case and then correlative inductive case. Additional properties such as minimizing network traffic along a node's upstream path is able to be verified simply as abstracting each node to be a receiver that only sends reservation requests when the node sees a new request. By applying this abstraction to all downstream channels, we can verify this property for each downstream node iteratively.
\bigbreak
To conclude their paper, the authors highlight that the inductive approach may work locally for a node, but fail for the entire system. As an example, they provide that delay on a per node basis may be within the acceptable specifications, but in the aggregate could fail delay requirements for the system as a whole. So, while certain end-to-end properties can be more easily verified by induction, not all lend themselves to this approach. The authors assert that the main benefit of their work is to verify the existence (or absence) of end-to-end deadlock or divergence behavior of a complex protocol. 

\subsection{Current State of Multicast Verification}
Multicast protocols have seen increased use over the past decade as the proliferation of connected devices, improved wireless communication technologies, and increased connectivity has led to a networking environment more focused towards communication between groups and within groups, rather than point to point communication characteristic of the bourgeoning Internet. This increase in connectivity and devices has led to an emphasis on creating robust multicast protocols that are both reliable and secure. Wireless technologies further increase the need for security, especially within the multicast framework where less hand-shaking (in general) between communication parties occurs. In order to ensure these characteristics are present within a multicast protocol, there is a push to formally verify these protocols, specifically for group oriented environments and wireless communications. It should be noted that the majority of work conducted in this area is more focused on the formal verification of specific multicast protocols using existing formal methods, rather than developing new formal methods and approaches for the multicast communications model in general.
\bigbreak
The following sections will highlight several papers that examine the verification of different properties of multicast communication: security primitives, wireless communication, reliability, and congestion control. Less detail will be afforded to each paper than in previous sections, since what follows is informational rather than providing background or a narrative of the development of the field of multicast verification. That being said, the reader should have a sufficient understanding of the methods and results for each paper.
\bigbreak
\subsubsection{Security}
Perhaps somewhat surprisingly, prior to focusing on the verification of multicast communication within wireless settings, the security guarantees of multicast protocols received early attention in \cite{Gorrieri2008} for either wired or wireless media. The authors specifically focused on the security of digital streams across multicast streaming protocols. These are of particular interest, because a significant amount of file sharing, live-streamed broadcasts, massive online video games, and even the pushing of software updates occur via multicast data streams. So, while this paper is not particularly concerned with verifying the communication properties of multicast protocols, it is concerned with verifying the application of security protocols and primitives (authenticity, integrity, and confidentiality) to a multicast stream. 
\bigbreak
In order to verify a variety of security properties, the authors focus on verifying a system with an arbitrary number of components (as exhibited by streaming digital signature protocols) as a composition of security verified subprocesses constructed carefully to preserve the security properties of the entire system. More plainly, the compositional principle provides sufficient proof to conclude that if each single process satisfies a single property, the composition of two or more \textit{processes} satisfies the compositions of two or more \textit{properties}. The authors employ this approach to verify a property for integrity (a stability against packet modification) and a secrecy property that requires the stream content to remain unknown to everybody but the sender and the intended set of receivers. They verify the presence of these properties for the Gennaro-Rohatgi protocol (a stream signing protocol) \cite{Gennaro2001}, the Efficient Multi-chained Stream Signature protocol (EMSS) \cite{Perrig2000}, the \textmugreek TESLA protocol (micro Timed Efficient Stream Loss-tolerant Authentication to provide authenticated wireless broadcast for sensor networks \cite{Perrig2002}), and a secret key multicast group distribution protocol, often referred to as the N Root/Leaf pairwise protocol \cite{rfc2627}.
\bigbreak
As previously mentioned, the authors are concerned with the analysis of integrity and secrecy properties. They consider two integrity properties, one untimed for EMSS and one timed for \textmugreek TESLA. For N Root/Leaf pairwise protocolthey consider consider the secrecy property. To formally verify these properties a schema called Generalized Non Deductibility on Compositions (GNDC) is used. This schema compares expected system behavior with a system behavior modified by some malicious process trying to interfere with expected execution. If these behaviors appear the same, then the intruder has had no real affect on the operation of the system and protocol, and the property of interest is verified. Using this framework the authors verify that both EMSS and \textmugreek TESLA enjoy integrity for whatever number of multicast receivers (\textmugreek TESLA must also have timed secrecy on its secret keys in order to ensure timed integrity). Additionally, the authors conclude that the N Root/Leaf pairwise protocol preserves the secrecy of a given message \textit{m} containing a given key \textit{k}
\bigbreak
In performing this analysis, the authors demonstrate the verification of multicast security protocols that can be implemented in real world systems, and thus, provide guaranteed security (for the formal definition of security) throughout the life of their operation for an arbitrary number of participants and components.
\bigbreak
\subsubsection{Wireless}

\subsubsection{Reliability}

\subsubsection{Congestion Control}

\bibliographystyle{ieeetr}
\bibliography{sem_bib}

\end{document}