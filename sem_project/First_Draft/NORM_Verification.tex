\documentclass[10pt, journal]{IEEEtran}
\usepackage{graphicx,latexsym}
\usepackage{longtable}
\usepackage{fullpage, setspace} %an example of how to specify two packages at once.
\usepackage[nottoc]{tocbibind}
\usepackage{textgreek}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[T1]{fontenc} % optional
\usepackage{amsmath}
\usepackage[most]{tcolorbox}
\usepackage[cmintegrals]{newtxmath}
\usepackage{bm} % optional

\lstset
{ %Formatting for code in appendix
    basicstyle=\footnotesize,
    numbers=left,
    frame=single,
    xleftmargin=2em,
    framexleftmargin=2.5em,
    %stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}

\makeatletter
\def\lst@makecaption{%
  \def\@captype{table}%
  \@makecaption
}
\makeatother

\title{Multicast Protocol Verification: Using Real-Time Maude to Verify the NACK Oriented Reliable Multicast Protocol}
\author{Caleb Bowers}
\date{11-26-2019}

\begin{document}

\maketitle
\begin{abstract}
This is placeholder text
\end{abstract}

\section{Introduction}
In the past thirty years researchers have produced significant improvements in how formal methods are used to verify computer networking protocols. Traditionally, during development and implementation, the protocol would undergo extensive testing as the primary method of verifying that the function of the protocol matched the design specification. If the protocol behavior mirrored that of the design specification, then researchers and designers felt confident enough to label the protocol ``verified,'' or at least stable enough for reliable use. This approach does not concretely verify the protocol, but does prevent obvious errors from existing and can come close to ensuring functionality in expected operational conditions. Extensive testing, however, only verifies the behavior of the specification for the specific domain tested, and does not logically verify the specification itself.

Extensive testing methods work fairly well for day to day unicast Internet protocols where the operating conditions are more predictable and the implementation less complex. There exists a gap, however, for multicast and broadcast networking protocols (hereafter, multicast\footnote{It should be noted that multicast is a subset of broadcast. Broadcast entails a sender transmitting to all network participants, whereas multicast describes a sender transmitting to a \textit{subgroup} of participants.}) and researchers have sought to develop more rigorous formal methods for these networking protocols. 

In multicast environments the participants are often widely distributed and senders only know the group address, rather than the address of each participant (as is the case in unicast). The multicast communications paradigm requires more complex reliability and transmission mechanisms in order to ensure that the protocol maintains efficient use of network resources (e.g, bandwidth). Implementing these mechanisms leads to an explosion of state space, which further limits the efficacy of extensive testing, since that is often domain specific and is limited in time by the number of actual testable domains. Additionally, as previously mentioned, a specification may produce proper behavior amidst most operational conditions, but still not be functionally guaranteed to match the design specification, so a possibility for error exists somewhere in the behavioral domain for that protocol. Formally verifying these complex multicast mechanisms, therefore, remains necessary and is increasingly important as more communication becomes distributed and asynchronous across multicast protocols.

The focus of this paper is to replicate and build off of previous verification efforts that sought to formalize an early draft version of the NACK Oriented Reliable Multicast Protocol (NORM) using the verification framework Real-Time Maude \cite{Lien2004, rfc5740, rtmaudeUrl, maudeUrl}. NORM provides reliable multicast communication amidst even significantly degraded network resources and leverages novel information theoretic methods to recover message information at the bit level, making it the state-of-the-art in reliable multicast communication. In order to provide these delivery guarantees, NORM's design is fairly complex due to its use of Forward Error Correction (FEC) codes, its internal timing methods, and its NACK (negative acknowledgement) based reliability guarantees. Its reliability guarantees make it a desirable protocol to use for multicast applications, but its complexity could make it susceptible to failure, since the state of operation can become easily obfuscated by the large functional state domain, especially as the network increases in size. The initial work focused on specifying and verifying only two of the more approachable, yet still certainly complex, components of the protocol: the local and global round trip time calculation and the data repair transmission algorithms. 

The goals of this paper focus on replicating and expanding the verification of the data repair transmission component of the NORM protocol specification to provide a more comprehensive understanding of the Real-Time Maude NORM model. I achieve this by expanding the original testing scenarios and creating a testing generation framework to provide improved systematic testing enabling a better understanding of the computational and time requirements needed by the Real-Time Maude implementation in order to verify/produce a result. The resulting work produces an analysis and regression testing framework that enables improvements to the Real-Time Maude NORM model to be made or allow a user to formalize a custom implementation of NORM and then compare results to the original Real-Time specification or more rigorously analyze their new specification beyond small sample initial state spaces for error and model timing analysis. 

\section{Related Work}
Multicast protocols enable a sender to communicate with a group of receivers simultaneously, and as such, require a higher level of complexity when attempting to provide reliability and security guarantees. While multicast protocols in design may be more complex than unicast communication paradigms, the approaches to their verification do not differ that significantly and a body of literature exists for general protocol verification dating back to the late 1970's \cite{Bochman1980}. A brief overview of some of the significant literature regarding the verification of both multicast protocols is provided before delving into background material.

\subsection{Multicast Protocol Verification}
As previously mentioned, multicast protocols can be significantly more complex than unicast protocols, since the communication originating from a sender can be destined for an arbitrary number of nodes at send time (as opposed to the lifetime of the packet in a unicast protocol). This complexity not only affects how to verify the underlying design of the communications protocol, but how to ensure certain desirable aspects of a communications protocol: security, wireless resilience, etc.

\subsubsection{Historical Multicast Verification}
Early examples of network protocol verification previously mentioned focused primarily on link level properties between fixed entities (e.g, sender and receiver) leveraging a fixed number of lower layer services and components. This approach does not enable the verification of protocols as they are used in the real world where communications happen between an exponential number of entities across complex protocols that make use of an arbitrary number of lower layer services, unicast or multicast. To account for the arbitrary nature of real protocol operational requirements, the researchers shifted from a strict model checking approach, to a technique that uses induction to prove correctness of protocol specifications and properties \cite{Creese1999}, \cite{Callahan1995} ,and \cite{Baptista1990}.

\subsubsection{Current State of Multicast Verification}
Multicast protocols have seen increased use over the past decade as the proliferation of connected devices, improved wireless communication technologies, and increased connectivity has led to a networking environment more focused on communication between and within groups, rather than point to point communications characteristic of the early Internet. This increase in connectivity and devices has led to an emphasis on creating robust multicast protocols that are both reliable and secure. Wireless technologies further increase the need for security, especially within the multicast framework where there occurs less hand-shaking (in general) between communicating parties. In order to ensure these characteristics are present within a multicast protocol, there is a push to formally verify these protocols, specifically for group-oriented environments and wireless communications. 

Prior to focusing on multicast protocol use in wireless settings, researchers turned to verifying additional security primitives for multicast network communication. The focus turned to verifying a system with an arbitrary number of components (as exemplified by streaming digital signature protocols) as a composition of security verified subprocesses carefully constructed to preserve the security properties of the entire system. This technique sufficiently proves that if each single process in a system satisfies a given single property, the composition of two or more \textit{processes} satisfies the compositions of two or more \textit{properties}. Examples using this composition method to demonstrate security satisfiability in multicast protocols are \cite{Gorrieri2008}, \cite{Martina2015}, \cite{Bella2002}, and \cite{Archer2002}.

The emphasis within the field of multicast protocol verification quickly shifted to wireless settings as technological improvements enabled mass communication across the medium. Of particular interest is the functionality of wireless multicast protocols in sparse and poorly resourced networks, generally called edge networks. Analysis of the MobiCast protocol provides an example of verifying a multicast protocol designed to operate within this sparse networking context \cite{Tan2000}. To verify this protocol, the authors develop a model of its functionality within the Prolog language and test this model for a variety of specification properties (i.e., the protocol operates in the way the design specifies) and safety properties (i.e., the protocol operates when it needs to). 

Most wireless multicast research is focused on the development of new and efficient multicast protocols, leaving the verification until later. One additional example is \cite{Anastasi2000}, which examines the verification of a multicast protocol used to coordinate distributed mobile computing processes. The authors use the Calculus of Communicating Systems \cite{Milner1989} and the Concurrency Workbench tool \cite{Cleaveland1996} to specify and verify their mobile computing multicast protocol. Prior to the work being replicated in this paper, NORM had not been formally specified or analyzed, but sees wide use both in wireless contexts and in secure communication environments, so formal analysis of NORM's functional correctness would benefit a large group of users and networking contexts. I wish to expand and improve a framework for testing the Real-Time Maude specification, which will enable

\section{Background}

\subsection{Real-Time Maude}

For communication protocols, time is inherently useful in constructing a communication paradigm and ensuring appropriate steps are taking in exchanging information. Since communicating nodes have no means of knowing whether a message will eventually arrive at its intended recipient, time plays a crucial role in helping nodes determine how to react to the receipt, or lack thereof, of a message/information when participating in a communication session. For example, if a node expects a reply to a previously sent message, it may set a timer to determine how long to wait for that reply before re-sending the message or moving ahead in a communication sequence \cite{Lien2004}.

Within the realm of computing there exists a subset of computing systems whose functionality depends on the passing of time in a real-world setting. These systems are referred to as \textit{real-time} systems as their execution is tightly coupled to the passage of ``real'' time. Within this context, protocols constitute such a system, and NORM in particular heavily leverages and depends on the passage of time for proper functionality. In order to approach the verification of such a protocol, a modeling tool requires additional mechanisms to address the timing constraints a real-time system experiences. The author in \cite{Lien2004} made use of the real-time specification language and analysis tool \textit{Real-Time Maude} \cite{rtmaudeUrl, Olvezky2004}. Real-Time Maude extends the foundational specification language \textit{Maude} \cite{maudeUrl, Clavel2002} based on a logic for modeling concurrent exchanges and evolution in distributed systems called re-write logic \cite{Meseguer1992}. Real-Time Maude enables the user to specify exactly how the change in a concurrent system depends on time. What follows is a high -level view of the theory behind Real-Time Maude, since for the purposes of this project and paper, knowing that Real-Time Maude can be used to specify, analyze, and verify real-time systems, such as NORM, suffices.

Real-Time Maude allows the user to analyze a specification of their system in the Maude language by:
\begin{itemize}
	\item \textit{Simulation}: User can specify a single behavior to simulate through the system specification
	\item \textit{Exhaustive Search}: Real-Time Maude can search through all possible system states for infinite or bounded time from some initial state looking for safe or unsafe states (based on desired property)
	\item \textit{Model Checking}: Using \textit{Linear Temporal Logic Formulas} Real-Time Maude verifies that from some given initial state the system satisfies the formula for all states or up to some time bounded set of states.
\end{itemize}

\subsubsection{Examples of Maude and Real-Time Maude}

Maude has been used recently to verify the YubiKey authentication framework, which is a type of two factor authentication used to verify user identity for network-based services such as remote login or file server access \cite{Escobar2018}. Additionally, Maude has a variety of application domains and has been used to verify programming languages (e.g., Java), analyze biological processes and entity interactions, and develop efficient and generally fault-free business production processes (operations management). 

Real-Time Maude has not seen as wide spread use as its parent program, but has been applied in a variety of fields, though primarily in the realm of communication protocols (making it well-suited to tackle NORM). Researchers have leveraged Real-Time Maude to specify and formally analyze the \textit{optimal geographical density control} algorithm used to coordinate nodes in a wireless sensor networks and the real-time updating, cost-aware scheduling algorithm CASH  \cite{Thorvaldsen2007, Caccamo2006}.

\subsubsection{Using and Analyzing Real-Time Maude}

Maude leverages rewrite logic (a set of conditional and unconditional logical deduction rules) to create specifications for systems in order to perform formal analysis and verification the state behaviors of those system \cite{Meseguer1992}. Likewise, Real-Time Maude further extends the theory of rewrite logic to encompass time dependent systems and executions by including syntax to specify the time constraints on a Maude command. A simulation of a specific behavior of a system can now be bounded for set time or can be simulated without a time constraint, allowing Maude to find unsafe states/behaviors. Similarly, Real-Time Maude enables time specifications for state space search methods and for evaluating linear temporal logic formulas. This enables users to evaluate time itself as a possible failure cause for system behaviors, which directly impacts functionality of a real-time system (such is the case for NORM).

\subsection{NORM}
In computer networking communication and protocol verification, communication is broken into three main paradigms
\begin{itemize}
	\item \textit{unicast}: A sender transmits to a single receiver. Internet protocols operate on this model.
	\item \textit{broadcast}: A sender transmits to all nodes on the network. This is how computers find printers on a local subnet.
	\item \textit{multicast}: A sender transmits to a subgroup of nodes on the network.
\end{itemize}

Multicast communication enables a sender to transmit a message to a specific group address, or a multicast address \cite{Lien2004}. Once the message is transmitted to this address, delivery of the message to every member of the group depends on the multicast network protocol. When specifying requirements for a multicast protocol, reliability is often provided by balancing the tradeoffs of feedback/retransmission strategies with the ability to scale to a large number of nodes across a wide network. If the protocol creates too much traffic, it will not scale well on its own as a communications protocol, nor will it be useful in larger networking contexts where the multicast protocol must share resources with other communication protocols.

Multicast is, at this point, incredibly popular for a variety of Internet level applications: distributed chat, online video games, and the pushing of software updates. Historically, in order to implement these services, a specialized multicast protocol would have be to be developed or cobbled together using the Internet Protocol stack in a specific manner. With the development of NORM, a lot of the complexity in early multicast implementation was removed, especially for the application uses often leveraging multicast: streaming, file transfer, distributed communications. NORM \cite{rfc5740} combines these application services into a transport layer protocol, which removes the need for the application layer to manage the multicast communication and communicate as it would using any Internet Protocol (e.g., UDP, TCP, etc.). Additionally NORM provides service guarantees amidst degraded network conditions or sparse networking environments by focusing on preventing, detecting, and correcting errors as they arise.

NORM can prevent errors due to congestion control by adjusting sender transmission rate in an adaptive manner and using reduced receiver feedback messages, thus preventing the network from being taxed by unnecessary control messages. In order to detect errors, NORM sequences each packet and the receiver can inform the sender of a successful receipt of data or a need to repair received data. Finally, NORM employs novel FEC encoding to correct errors at the receiving end of the packet, but if this is not enabled, the sender can retransmit lost or damaged packets.

\subsubsection{NORM Overview}
The development of NORM began as an Internet Engineering Task Force (IETF) Internet-Draft and has evolved into a full-fledged Internet Standard in the Request For Comments 5740 \cite{rfc5740} in 2009. In \cite{Lien2004}, whose work I am replicating and seeking to expand, the author used an early draft of NORM that became obsolete in 2003, so room exists to update her work and examine how her Real-Time Maude specification reflects the current Internet Standard specification of NORM. The goal of NORM is to provide reliable, efficient, scalable, and robust transport of large amounts of data over an IP multicast network. To this end, NORM employs:
\begin{itemize}
	\item \textit{NACK based packet repair}: Receivers request repair of packets via a negative-acknowledgement (NACK) when they encounter packet loss
	\item \textit{Reduced receiver feedback}: Receivers are not required to acknowledge receipt of every packet
	\item \textit{Congestion Control}: As mentioned, both sender and receiver can adjust transmission rates to account for network traffic load
\end{itemize}

The main subject interest and analysis will be the data transmission component of NORM, which is responsible for the transmission, delivery, and repair of packets transmitted from sender to receivers. These data transmissions can be objects (i.e., messages broken into packets/datagrams) or "infinite" streams of data marked with an object identifier unique to streams. NORM accomplishes the transmission of these objects using the following messages:

\textbf{Sender}
\begin{itemize}
	\item \textit{NORM\_DATA}: Used for sending and retransmitting data segments (depending on internal flags) from the application layer
	\item \textit{NORM\_CMD}: Control messages in NORM to administer operation.
	\begin{itemize}
		\item \textit{NORM\_CMD(CC)}: used to monitor network congestion and establish round trip times for receiver group(s)
		\item \textit{NORM\_CMD(FLUSH)}: Once the sender transmits this message, the receivers know that it is preparing to flush (delete) queued data and repair segments, which means receivers must submit any remaining repair requests if they wish to recover lost data
		\item \textit{NORM\_CMD(SQUELCH)}: Senders transmit this message to all receivers if the sender has received a repair request for data it can no longer repair. This message provides information about which data objects are still eligible for repair
	\end{itemize}
\end{itemize}

\textbf{Receiver}
\begin{itemize}
	\item \textit{NORM\_NACK}: Used to request repair of lost or incomplete data segments
	\item \textit{NORM\_ACK}: Used to acknowledge NORM\_CMD messages from sender
\end{itemize}

The sender messages \textit{NORM\_DATA}, \textit{NORM\_CMD(FLUSH)}, and \textit{NORM\_CMD(SQUELCH)}; and both receiver messages are used in the data transmission component of NORM, which I will be modeling and analyzing in Real-Time Maude. There are three sections in the transmission and repair of data: sender transmission (\textit{NORM\_DATA}, receiver repair request (\textit{NORM\_CMD(FLUSH)}, \textit{NORM\_NACK}), and sender NACK processing/repairing (\textit{NORM\_CMD(FLUSH)}, \textit{NORM\_CMD(SQUELCH)}).

\subsubsection{NORM Specification and Model}
The Real-Time Maude specification model does not include components for congestion control, since this functionality is not crucial to ensuring reliability, but exists to relieve excessive network traffic. This specification further models communication with one sender to arbitrarily many receivers (\textit{one-to-many}). While NORM can support arbitrarily many senders to arbitrarily many receivers, most actual implementations leverage a \textit{one-to-many} paradigm (e.g., pushing a software update), so this is most beneficial to analyze. Additionally, all communication between senders and receivers is multicast\footnote{NORM can operate with transmission multicast from sender and the receivers have a unicast channel back to the sender}. Only finite data objects (e.g., messages, file transfers, etc.) will be examined without the use of FEC codes (these are used for packet recovery and do not affect instantiated NORM session communication between sender and receivers\footnote{An instantiated NORM session cannot add FEC encoding midway, but must have this specified beforehand. Of course, FEC encoding will reduce the amount of repair requests, so communication between senders and receivers would be impacted, but within the already defined NORM communication paradigm.})

Additionally, the following assumptions are made in the Real-Time Maude specification:
\begin{enumerate}
	\item Though NORM can operate within dynamic mobile contexts, only static topologies will be considered (for ease of analysis)
	\item Time will progress in the Maude analysis only when those NORM objects and components specified are operating in time (e.g., packet transfer will consume time, but instantaneous actions, such as packet wrapping for transmission, will not). 
	\item The random backoff timeout algorithm, which is critical to the receiver transmitting NACK repair requests and in distributing the round trip time calculations on a per receiver basis has remain unchanged in updated design specifications of NORM.
\end{enumerate}

\section{NORM Data and Repair Transmission Component}
What follows is an explanation and some brief detail of the Real-Time Maude specification for the data transmission component of NORM. The author in \cite{Lien2004} originally had some difficulty in discerning particular sections (to be highlighted) due to ambiguity in the IETF draft specification. Fortunately, the ambiguities identified by the author have all been resolved in the updated specification. The resolution of these ambiguities will inform my attempts at updating the Real-Time Maude specification originally found in \cite{Lien2004}.

\subsection{Specification}
The author of \cite{Lien2004} identified three areas of ambiguity in the IETF draft version of NORM that required her to make a decision how the specific ambiguous piece of NORM functionality would be modeled in Real-Time Maude. Her decisions were additionally informed by the designers of NORM and recently (to her) released updated versions of NORM. The author identified the following areas as underspecified or ambiguous:
\begin{enumerate}
	\item \textit{Receiver NACK Cycle Initiation}: Normally, a NORM receiver will initiate the NACK cycle at specific events: NormObject boundaries, FEC coding block boundaries, or receipt of NORM\_CMD(FLUSH) messages. An alternative, self-initiating NACK cycle option also exists for receivers when no data is currently being received from a sender. The original IETF draft provides no details on this self-initiating NACK cycle process. Updated versions of the NORM standard, however, do provide detail on this operation and specifying this behavior will consitute part of my results.
	\item \textit{Sender NACK Accumulation Timeout}: This ambiguity arose from a discrepancy between the 2003 NORM IETF draft document and the NORM building blocks document \cite{rfc5401}. The timeouts were specified differently in the two documents, and the IETF draft listed timeout did not allow for the receiver feedback suppression algorithm timeout to expire. This was corrected at the time of her original drafting of the Real-Time Maude specification.
	\item \textit{Sender FLUSH Process}: The IETF draft of NORM ended the request and repair process between senders and receivers via a flag (NORM\_FLUSH\_FLAG\_EOT) embedded in the NORM\_CMD(FLUSH) message. This is the same message that informs receivers to request repairs, so it is unclear that if a receiver receives a NORM\_CMD(FLUSH) message with the flag set to end transmission that it would have time to submit last minute repair requests. This problem is remedied in the current version of NORM by simply removing that flag and introducing a new message NORM\_CMD(EOT) that explicitly informs receivers that transmission is ending allowing them to exit the NORM session gracefully. Implementing this message class in the Real-Time Maude specification will also be a subject of my results.
\end{enumerate}

The data transmission component is broken up into two classes for the Real-Time Maude specification: \texttt{DTsender} and \texttt{DTreceiver}, which inherit from the base classes Sender and Receiver, respectfully. An application layer module, \texttt{APPLICATIONS}, defines applications to send and receive data. The sender application enqueues data for transmission and the receiver application collects data received by the receiver node \cite{Lien2004}. The author further defines an \texttt{OBJECT} message, which will be a "base" message that the other message types will "inherit" (i.e., wrap) for the different types of NORM messages defined. The following messages are defined for the data transmission component: NORM\_DATA, NORM\_CMD(FLUSH), NORM\_CMD(SQUELCH), and NORM\_NACK. My analysis will add the additional message NORM\_CMD(EOT) and modify the NORM\_CMD(FLUSH) message definition to account for the end of transmission message.

In Real-Time Maude, rules define the behavior of a system on the Maude objects that the model comprises. The author originally defined several rules for \texttt{DTsender}:
\begin{itemize}
	\item The transmission of new data content
	\item The flush (e.g., repair request) process
	\item The NORM\_NACK accumulation period
	\item The repair of data transmission
	\item Timeout to accept repair requests
	\item Notifying receivers of invalid repair requests. 
\end{itemize}
\noindent
Rules defined for \texttt{DTreceiver} consist of:
\begin{itemize}
	\item The initiation of the NACK cycle at NormObject boundaries
	\item NACK cycle initiated by receipt of NORM\_CMD(FLUSH)
	\item Repair message reception
	\item Forwarding data up to application layer
	\item Accumulating external repair requests from other receivers to forward to sender node
	\item Transmitting repair request after holdoff timeout
	\item Cancel invalid repair requests
\end{itemize}

The previous classes, modules, and rules are required in Real-Time Maude to formally analyze and verify a system using the Maude/Real-Time Maude framework. Once these system components are defined, the system can be evaluated by defining a variety of initial states from which property satisfiability and system correctness can be analyzed. These states will be defined in the Analysis section.

\subsection{Analysis Replication}

Several hurdles were encountered when attempting to replicate the analysis of the Data Transmission and Repair component using the original Real-Time Maude specification from \cite{Lien2004}. I had to replicate a testing environment used in the early 2000's on an operating system and hardware that was the result of almost twenty years of constant improvement. The following steps were required in order to replicate the analysis from the original Real-Time Maude investigation.

The author used Real-Time Maude 2.0, which was released in in 2004 and operated on top of Maude 2.0 (released in 2003). Locating Real-Time Maude 2.0 was not too difficult and only consists of a Maude file that defines the timing mechanisms for real-time analysis. Maude 2.0 proved somewhat more complex. Initially, I attempted to build version 2.0 from source, but was continually met with compiler errors that resulted from significant changes in linux c compiler design over the past 16 years. Eventually, I located a pre-built unix binary that I was able to execute on my Linux system and only needed to invoke this binary with the Real-Time Maude 2.0 definitions file in order to run Real-Time Maude. Maude 2.0, however, could not run initially within my terminal, since it contained too many color options and additional graphics options that Maude did not know how to parse. This was easily remedied by downloading a terminal vt100 emulator: xvt. Within xvt I was able to execute Real-Time Maude and run some example tests from the distribution website \cite{rtmaudeUrl}.

The next hurdle involved implementing the Real-Time Maude specification of NORM in my Real-Time Maude environment. Initially, I attempted to copy the entire specification from the appendix of \cite{Lien2004}, but this proved to be an incomplete specification and lacked the object-oriented architectural structure required by the Real-Time Maude methods. Eventually, I found the author's code in an online repository of Real-Time Maude use cases. I fairly quickly was able to execute her files after some minor commenting and syntax errors (Statements, both in Maude and Real-Time Maude require termination with periods, some of which were missing from the files in the repository. The files seemed to be in a state of mid-completion/mid-testing, so were not completely polished.) After cleaning up the coding errors, I began replicating the tests the author developed in her initial Real-Time Maude analysis of NORM.

\subsubsection{Data and Repair Properties}

The author defined several properties for her analysis of the data and repair component of NORM ranging from examining initial sate behavior to assessing LTL logic formulas on the system. The following properties were defined for the data and repair component and I successfully replicated all of them within my Real-Time Maude environment.
\begin{itemize}
	\item 
	
\end{itemize}

\subsection{Expanding Analysis}


\section{Conclusion}
``It is kaput.'' - Baron Manfred von Richthofen. To be completed.

\bibliographystyle{IEEEtran}
\bibliography{sem_project_bib}

\end{document}